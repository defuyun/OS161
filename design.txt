

========== frame table and hash page table initialization ========


A major issue was that we had to allocate the frame table and
hash page tables (the underlying layer of the VM) without the
use of any kmalloc calls (because kmalloc itself depends on
what we are implementing).

We determined the total number of frames in memory,
allocated the frame table at the top of OS161,
and subtracted the size that will be used by OS161 itself.
We then designed our hash page table based on twice the number of
entries in the frame table, and placed it directly at the bottom
of the frame table. When determining the number of frames,
we use ceiling to ensure that pages are aligned and frames are
marked as used for any blocks not aligned wit 4K.

We then calculated the combined size of the frame table and hash
page table, and determined the number of frames occupied by
these two objects through division and taking the ceiling. We
did so similary for OS161 (at the bottom of the memory), taking
the ceiling as well. We then marked these frames occupied by them
as within the frame table.

The frame table entries are index-chained, such that the free
frame list is kept within the frame table entries themselves.
We do not require an extra structure to keep track of the free
frames. Frame table entries have a member called status which
we assign as either free, used, or reserved (reserved means
being used by the frame table/hash page table/OS). Frame table
entries that are marked as free have a member called "int free",
which contains the index of the next free frame. We keep a global
ft_next_free variable to keep track of the first free frame.


=========== alloc page and freeing pages =========


When allocating a page, if the frame table has already been
initialized, we would grab the first free frame through
the global variable, and update the global variable to refer to
the next one in the free frame list. We would then zero-fill
this entire page, convert it into a kernel virtual address,
and return.

Similary, when freeing a kpage, we AND EQUALS the lower 12 bits,
convert it to a paddr, and update the corresponding entry within
the frame table as well as the global first free frame index.

Sync primitives are used for the frame table and hash page table
to ensure mutual exclusion when accessing these data structures.


============== hash page table ==================


this assigment is composed of 3 parts, we have:
1. a frametable for the actual memory mapping
2. a hash page table for virtual memory mapping
3. vm_fault for processing tlb miss

the hash page table consists of 4 member variables:
1. inuse -- tells you whether this table is being used
2. entry_hi -- the vpn
3. entry_lo -- the kernel virtual adress when inserting in the tlb.
		we need to convert it into phyisical address
		along with some permission and state bits
4. pid -- the process id/address space id that will be used to
			uniquely identify hash page entries, whether it
			belongs to a given address space.

The hash page table uses a hash function based on the pid and vpn,
and it maps to an index which is the location on
the hash page table array that we initialized earlier right below the frame table.
In case the index already refers to an entry currently in use (collision),
we use double hashing to find the next free index.

Double hashing was the best design decision chosen. Linear probing took
an unacceptably long performance hit, external linked lists/separate chaining
suffered too much internal fragmentation, while internal index-chaining degrades
to linear probing performance after just a few inserts/removes (because
indexes may refer to an entry that was moved elsewhere in an index-chaining
structure).

We timed double hashing, and it was able to create/fork processes quickly and
pass the tests a lot faster than the other methods.


================= entry lo bits and permission management ====================


the entry_lo has 20 bits for the kernel virtual address,
as well as global, valid, dirty, nocache bits that are MIPS defined and
dependent on the TLB. The dirty bit is set/cleared depending on the
write permissions of the entry. This allows the TLB to write if write is allowed
(by setting the TLB dirty bit).

Below are four additional bits that we defined in order to manage
read, write, and execute permissions.
1. read
2. write
3. execute
4. soft write : This bit is initially set by the "define_memory" function,
				which is called by as_define_region.
				This bit allows vm_fault to ignore the permission bits during loading.
				If vm_fault sees this bit, it will allow reading/writing, since this
				bit indicates that the OS is still loading in the segments. This bit
				will later be cleared by as_complete_load, so that vm_fault will default
				to checking the write bit.


=============== address space functions ================


In as_define_region, we allocate hash page table entries for the mem segments,
but we initially set entry_lo kernel virtual memory to 0. We do this optimization,
because this speeds up forking by just allocating hpt entries but not yet
immediately finding and allocating free frames.
Later, in vm_fault, if the fault was caused by such a page entry that
we haven't allocated a frame, we call alloc_kpages to actually allocate
the frames. The frames are only loaded/allocated when needed, which is another
optimization.

In as_copy, we copy the hpt entry of the old addrespace, allocate new frames,
and copy over the contents of the memory using memmove. Of course, we check
to ensure that the hpt entries that we are copying from belong to the old
address space, and that they are currently in use as well.

In as_destroy we delete the entries in the hash page table with the same pid, and
also call free kpages on the entry lows.

as_prepare_load does not need to do anything, because
as_define_region called the static function "int define_memory",
which set an SWRITE bit within each entry_lo.
The SWRITE bit (soft write bit) indicates to the vm_fault handler
and ourselves that this segment is still being loaded in by the OS during load_elf.
When VM Fault is triggered, if it sees an
SWRITE bit within entry_lo, it will ignore the permissions bits
stored and instead temporarily allow read/write.
The SWRITE bit is later cleared by as_complete_load.

in as_complete_load we loop through all entries in the hash page table and clear the
SWRITE bit of any entry with soft write bits on,
then we flush the tlb because there might be leftover entries with the soft write bit.

as_activate and deactivate just flush the tlb, because we wouldn't want other processes
to be able to see what another process was accessing memory from after a context switch.
flushing it ensures that processes cannot see each other's memory accesses.


============== vm_fault =======================


In vm_fault, we check if the faultaddress was accessing an address above MIPS_KSEG0,
or if the fault type was accessing a read only memory, or if the address space is NULL.
In this case, we return the corresponding error values to the user.

If none of the above were true, then we would again hash the vpn and asid to obtain
the hashed index, as well as double hash to obtain the jump distance during probing.
(Double hashing = It was previously mentioned above that this was actually the fastest
(we timed it) and speediest way of accessing the HPT).

If we fail to find a matching entry with the asid and vpn,
or if the fault type did not match the permission bits / softwrite bits contained within
the entry's entry_lo, then we also return an appropriate error value.

The fault may also be due to an entry where we earlier inserted a hash page table entry
but did not immediately allocate a frame (as explained above, this massively
optimizes/speeds up forking and creating new address spaces).
If this was the case, then we would call
allocate_memory to allocate a frame to this hash page table entry.

If the fault was an VM_FAULT_WRITE, but the write permission bit is set within entry_lo,
then we set the dirty bit, because the dirty bit is the only way that the TLB checks
to see whether a write operation is allowed.

We will then call tlb_random to randomly write our entry hi and entry lo to the TLB.